#===============================================================================
# IDA RunTrace (UI Part)
# Give user some dynamic information, which include registers' value and some memory's value, to support RE.
# The data is read from a database generated by PIN. (the pin tool is context_logger.dll)



# Usage:
# HotKey (10)
#   [List all functions that have comments] Press "Shift-l"

#                         [Toggle comments] Press "Ctrl-ShLift-l"
#               [Toggle global/local index] Press "|"

#    [Select current instruction iteration] Press "i"
#  [Previous current instruction iteration] Press "["
#      [Next current instruction iteration] Press "]"

#                          [Backwards view] Press "Ctrl-["        
#                            [Forward view] Press "Ctrl-]"        
#       (Backward and forward are specially used for loop.)

#           [Previous executed instruction] Press "{"        
#               [Next executed instruction] Press "}"


# If you want to make comments, please write them before "__" index marker. 
#
# Created by: razygon 03/21/2013 
#last update 07/29/2013
#===============================================================================

import sqlite3
import idc
import idapython
import idaapi
import idautils

#Global constants
_IDARUNTRACE_GUID          = '6c3e36b6-3a6b-4907-952f-e71db2a298b3'  
_IDARUNTRACE_HOTKEY        = 'Shift-l'
_IDARUNTRACE_CLEARORSHOW   = 'Ctrl-Shift-l'
_IDARUNTRACE_GlobalorLocal = '|'
_IDARUNTRACE_CHOOSE        = 'i'
_IDARUNTRACE_PREVIOUSINDEX = '['
_IDARUNTRACE_NEXTINDEX     = ']'
_IDARUNTRACE_BACKWARD      = 'Ctrl-['
_IDARUNTRACE_FORWARD       = 'Ctrl-]'
_IDARUNTRACE_PRENODE       = '{'
_IDARUNTRACE_NEXTNODE      = '}'

_g_IsFirstRun = True
g_ColorSnapshot = None

def DEBUG_PRINT(str):
#     print str
    return

class IdxChoose2(idaapi.Choose2):
    def __init__(self, title, cols, items, deflt = 1):
        idaapi.Choose2.__init__(self, title, cols)
        self.items = items
        self.deflt = deflt 
    
    def OnClose(self):
        return

    def OnGetLine(self, n):
        return self.items[n]

    def OnGetSize(self):
        return len(self.items)

    def OnDeleteLine(self, n):
        del self.items[n]
        return n

    def show(self):
        return self.Show(True)

class NODE(object):
    def __init__(self, shown):
        self._shown = shown
        self._idx_count = 0
        self._idx_list = []
        self._xref_from = []
        self._xref_to = []
    
    def count(self):
        self._idx_count +=1
        
    def append(self, node):
        self._idx_list.append(node)

class CommDB:

    def __init__(self, commMarker = '__'):
        self._commMarker = commMarker
        self._declareMemberVars()

    
    def callFromConfig(self, dbPath):
        print sqlite3
        for ea in self._dbDict.keys():
            self._RmComm(ea)
#            idc.SetColor(ea,self.CIC_ID,self.IDA_LF_COLOR_ORIGIN)
        global _g_IsFirstRun
        if (_g_IsFirstRun):
            _g_IsFirstRun = False
            self.LoadPersistData()
            print 'load color store finished'
        self.printUsage()
        self._declareMemberVars()
        self._ConstructDB(dbPath)
        self.DefaultView()
    
    def _declareMemberVars(self):
        self._dbDict = {} 
        self.insCount = 0
        self._tables = []
        self._tablelist = [] # the functions have comments [addr,name,show]
        self.BACKWORD = 1 # Default show forward
        self._choose_id = -1
        self._choose_idx = -1
        self._choose_ea = 0
        self.tbls = []
        self._global = 1
        self.lastnode_ea = 0
        self.lastnode_color = 0x0
        self.colorsnapshot = {}
        self.colorsnapshot_startEA = 0
        
        self.CIC_ID = idc.CIC_ITEM  #default
        
        self.max_ea = 0
        self.max_idx = 0
        self.min_ea = 0
        self.min_idx = 0
        
        self.IDA_LF_COLOR_ORIGIN = idapython.GetTrueBackgroundColorHexRGB()
        
        if (idapython.IsBackgroundDark()):  #You an change the color you like here.
            self.IDA_LF_COLOR_TAG       = 0x1E5374
            self.IDA_LF_COLOR_LOOP1     = 0x66FF66
            self.IDA_LF_COLOR_LOOP2     = 0xFFCC66
            self.IDA_LF_COLOR_LOOP3     = 0xCCCCFF
        else:
            self.IDA_LF_COLOR_TAG       = 0x80ECFF
            self.IDA_LF_COLOR_LOOP1     = 0x66FF66
            self.IDA_LF_COLOR_LOOP2     = 0xFFCC66
            self.IDA_LF_COLOR_LOOP3     = 0xCCCCFF
            
            
    def LoadPersistData(self):
         global g_ColorSnapshot

         g_ColorSnapshot = idapython.PersistStore('LastFunction_ColorSnapshot', _IDARUNTRACE_GUID)        
          # Load persistent data
        
         g_ColorSnapshot.Load()
         if (g_ColorSnapshot.data is None):
             g_ColorSnapshot.data = {}
             g_ColorSnapshot.Save()
#          g_ColorSnapshot.data = {}  #  just for test

    
    # seems the to/from is confused... these two functions is just for far call.
    def Get_Xref_to(self, ea): 
        DEBUG_PRINT('get_xref_to')
        x = idaapi.xrefblk_t()
        statue = x.first_from(ea, idaapi.XREF_ALL)
        while statue:
            self._dbDict[ea]._xref_to.append(x.to)
            statue = x.next_from()
        
        statue = x.first_from(ea, idaapi.XREF_DATA) 
        while statue:
            self._dbDict[ea]._xref_to.remove(x.to)         
     
    def Get_Xref_from(self):
        DEBUG_PRINT('get_xref_from')
        x = idaapi.xrefblk_t()
        statue = x.first_to(ea, idaapi.XREF_ALL)
        while statue:
            self._dbDict[ea]._xref_from.append(x.frm)
            statue = x.next_from()
        
        statue = x.first_to(ea, idaapi.XREF_DATA) 
        while statue:
            self._dbDict[ea]._xref_from.remove(x.frm)
        
    def _ConstructDB(self, dbPath):
        sqliteConn = sqlite3.connect(dbPath)
        sqliteCur = sqliteConn.cursor()
        
        def closeDBConn():
            sqliteCur.close()
            sqliteConn.close()
        
        moduleName = idc.GetInputFile()
        moduleBase = idaapi.get_imagebase()
        DEBUG_PRINT('Module Name' + moduleName)
        print('Module Base 0x%x' %(moduleBase))
        
        sqlTbls = '''SELECT name FROM sqlite_master WHERE type='table' AND name!='XRef' AND name!='idx_tbl' '''
        sqlXRef = 'SELECT * FROM XReF'
        sqlCheck = '''SELECT name FROM sqlite_master WHERE type='table' AND name='XRef' '''
        sqlCrtTbl = 'CREATE TABLE XRef(Rva INTEGER PRIMARY KEY, XFrom TEXT, XTo TEXT)'
        sqlInsert = 'INSERT INTO XRef (Rva, XFrom, XTo) VALUES (?, ?, ?)'
        
        insCount = 0
        insAddr = 0xffffffff
        self.tbls = sqliteCur.execute(sqlTbls)

        for tbl in self.tbls:
            table = str(tbl).strip('\'(),u')
            self._tables.append(table)
            
        for tbl in self._tables:
            sqlComm = 'SELECT * FROM ' + str(tbl) + ' ORDER BY ins_rva ASC, Idx ASC '
            canEA = int(tbl.strip('t'),16)+ moduleBase
            item = [hex(canEA),idc.GetFunctionName(canEA),'0']
            self._tablelist.append(item)
            for row in sqliteCur.execute(sqlComm):
                if insAddr != (row[1]+moduleBase):
                    insAddr = moduleBase + row[1]
                    self._dbDict[insAddr] = NODE(False) 
                    insCount += 1          
                idxnode = [row[0],row[2].strip('{} ').encode('ascii','ignore')]
                self._dbDict[insAddr].append(idxnode)
                self._dbDict[insAddr].count()   
        
        table_statue = sqliteCur.execute(sqlCheck)
        str_t = ''
        for t in table_statue:
            str_t = str(t).strip('\'(),u')
  #    print 'str_t' + str_t
        if 'XRef' != str_t: # create XRef TABLE
            sqliteCur.execute(sqlCrtTbl)
            for ea in self._dbDict.keys():
                DEBUG_PRINT('0x%x'%(ea))
#                self._dbDict[ea]._xref_from = []
#                self._dbDict[ea]._xref_to = []
                fr = idautils.CodeRefsFrom(ea,1)
                for adr in fr:
                    DEBUG_PRINT('FROM---0x%x'%(adr))
                    self._dbDict[ea]._xref_from.append(adr)
                to = idautils.CodeRefsTo(ea,1)
                for adr in to:
                    DEBUG_PRINT('TO---0x%x'%(adr))
                    self._dbDict[ea]._xref_to.append(adr)
                x_fr = [int(x)-moduleBase for x in self._dbDict[ea]._xref_from]
                x_to = [int(y)-moduleBase for y in self._dbDict[ea]._xref_to]
                sqliteCur.execute(sqlInsert,(ea-moduleBase, str(x_fr), str(x_to)))
            sqliteConn.commit()
        else:   #read data from the table
            for row in sqliteCur.execute(sqlXRef):
                ea = row[0]+moduleBase
                x_fr = row[1].encode('ascii','ignore').strip('[]')
                x_to = row[2].encode('ascii','ignore').strip('[]')
                if '' == x_fr:
                    self._dbDict[ea]._xref_from =  []
                else:
                    self._dbDict[ea]._xref_from =  [int(x)+moduleBase for x in x_fr.split(',')]
                if '' == x_to:
                    self._dbDict[ea]._xref_to =  []
                else:
                    self._dbDict[ea]._xref_to =  [int(x)+moduleBase for x in x_to.split(',')]
            print 'XREF DONE'
        
        print str(insCount) + ' instructions covered.'     
        closeDBConn()
    
    def _debugView(self):
        for ea in self._dbDict:
            DEBUG_PRINT('0x%x  %d' %(ea,self._dbDict[ea]._idx_count))
            DEBUG_PRINT(self._dbDict[ea]._idx_list)
 
    def _GetFuncRange(self, ea):
        DEBUG_PRINT('_GetFuncRage')
        return (idaapi.get_func(ea).startEA, idaapi.get_func(ea).endEA - 1)
    
    def _ApdComm(self, ea, id):
#        DEBUG_PRINT('_ApdComm')
        g_mark = ' '
        if self._global == 1:
            idx = self._dbDict[ea]._idx_list[id][0]
            g_mark = '_g'
        else:
            idx = self._dbDict[ea]._idx_list[id][0] - self._dbDict[idaapi.get_func(ea).startEA]._idx_list[0][0]
            g_mark = '_L'
            
        idxcomm = self._dbDict[ea]._idx_list[id][1]
        comm = self._commMarker + str(idx) + g_mark +' ' +str(idxcomm).strip('{}') 
        oldComm = str(idc.GetCommentEx(ea, 0))
        tag = ''
        for xref in idautils.CodeRefsTo(ea, 0):
            if xref !=[]:
                if ea != idaapi.get_func(ea).startEA and oldComm == 'None':
                    comm = '\n' + comm                    
                break              
        
        if(oldComm != 'None'):
            comm = oldComm + '\n' + comm
        idc.MakeComm(ea, str(comm))
        self._dbDict[ea]._shown = True
        return
    
    def _RmComm(self,  ea):
        oldComm = str(idc.GetCommentEx(ea, 0))
        startIdx = oldComm.find(self._commMarker)
        if(startIdx != -1):
            comm = oldComm[0:startIdx]
            idc.MakeComm(ea, str(comm).strip())
            self._dbDict[ea]._shown = False
        return  
    
    def _showComms(self, startAddr, endAddr, id):
        self.ColorCompare()
        self._delComms(startAddr, endAddr)  # keep or remove?
        print '_showComms start 0x%x, end 0x%x'%(startAddr,endAddr)
        self.colorsnapshot_startEA = startAddr
        self.colorsnapshot = {}
        for ea in range(startAddr, endAddr+1):
            if ea in self._dbDict.keys():
                self._ApdComm(ea, id) 
                self.colorsnapshot[ea] = idc.GetColor(ea,self.CIC_ID)
                if ea not in g_ColorSnapshot.data.keys() and self.IDA_LF_COLOR_ORIGIN != idc.GetColor(ea,idc.CIC_ITEM):
#                     print 'line color ' + hex(idc.GetColor(ea,idc.CIC_ITEM))
                    g_ColorSnapshot.data[ea] = idapython.GetLineColor(ea)
                    g_ColorSnapshot.Save()
        return
        
    def _delComms(self,  startAddr, endAddr):  #######
        global g_ColorSnapshot
        for ea in range(startAddr, endAddr+1):
            if ea in self._dbDict.keys():
                self._RmComm(ea)
                if ea in g_ColorSnapshot.data:
                    idc.SetColor(ea,self.CIC_ID, g_ColorSnapshot.data[ea])
                    self.colorsnapshot[ea] = g_ColorSnapshot.data[ea]
                else: 
                    idc.SetColor(ea,self.CIC_ID,self.IDA_LF_COLOR_ORIGIN)
                    self.colorsnapshot[ea] = self.IDA_LF_COLOR_ORIGIN
        return
    
    def GlobalorLocal(self):
        origlobal= self._global
        views = ['1','2','3']
        if self._global == 1:
            tmpglobal = 0
        else:
            tmpglobal = 1
        c_ea = idc.ScreenEA()        
        (c_startEA,c_endEA) = self._GetFuncRange(c_ea)
        indexs = [i for i,item in enumerate(self._tablelist) if item[2] in views]
        for index in indexs:
            ea = int(self._tablelist[index][0],16)
            DEBUG_PRINT( ea)
            (startEA,endEA) = self._GetFuncRange(ea)        
            if startEA == c_startEA:
                c_index = index
                continue
            self._delComms(startEA,endEA)  
            self._tablelist[index][2] = '0'
        for ea in range(c_startEA,c_endEA+1):
            if ea in self._dbDict.keys():
                if self._dbDict[ea]._shown == True:
                    idx = self.GetIDX(ea)
                    id = self.GetID(ea, idx)                    
                    oldComm = str(idc.GetCommentEx(ea, 0))
                    startIdx = oldComm.find(self._commMarker)
                    if(startIdx != -1):
                        comm = oldComm[0:startIdx]
                        idc.MakeComm(ea, str(comm).strip())                                           
                    self._global = tmpglobal    
                    self._ApdComm(ea,id) 
                    self._global = origlobal         
       
        self._global = tmpglobal             
        return
 
            
 
    def _showFunctions(self):
        DEBUG_PRINT('IN _showFunctions')
        try:
            ea = idc.ScreenEA()
            deflt_ea = idaapi.get_func(ea).startEA
        except:
            deflt_ea = int(self._tablelist[0][0],16)  
        deflt_id = 1
        views = ['0','1','2','3']
        for view in views:
            if [hex(deflt_ea),idc.GetFunctionName(deflt_ea),view] in self._tablelist:
                deflt_id = self._tablelist.index([hex(deflt_ea),idc.GetFunctionName(deflt_ea),view]) + 1
#        if [hex(deflt_ea),idc.GetFunctionName(deflt_ea),'0'] in self._tablelist:
#            deflt_id = self._tablelist.index([hex(deflt_ea),idc.GetFunctionName(deflt_ea),'0']) + 1
#        if [hex(deflt_ea),idc.GetFunctionName(deflt_ea),'1'] in self._tablelist:
#            deflt_id = self._tablelist.index([hex(deflt_ea),idc.GetFunctionName(deflt_ea),'1']) + 1
            
        title = "Functions with Comments"
        cols = [['Address',10],['Function Name',15],['Show',4]]
        chooser = IdxChoose2(title, cols, self._tablelist, deflt = deflt_id)
        id = chooser.show()
        if -1==id:
            return 0
        else:
            ea = int(self._tablelist[id][0],16)
            return ea
        #hex(int(self._tablelist[id][0],16))
    
        
    def Get_previous_ea_id(self, ea, id, local):
        DEBUG_PRINT('Get_previous_ea')
        theone = [0,[-1,'']]
        next_idx = self._dbDict[ea]._idx_list[id][0]-1
        if [] != self._dbDict[ea]._xref_to:
            for canEA in self._dbDict[ea]._xref_to:
                if canEA not in self._dbDict.keys():
                    continue
                if local:
                    if canEA not in range(idaapi.get_func(ea).startEA, idaapi.get_func(ea).endEA):
                        continue
                for nd in self._dbDict[canEA]._idx_list:
                    if local:
                        if nd[0] < self._dbDict[ea]._idx_list[id][0] and nd[0] > theone[1][0]:
                            theone = [canEA,nd]
                    else:
                        if nd[0] == next_idx:
                            theone = [canEA,nd]
                            break      
        if 0 == theone[0] and 0 == local:
            for addr in self._dbDict.keys():
                for [i,j] in self._dbDict[addr]._idx_list:
                    if i == next_idx:
                        next_ea = addr
                        next_id = self.GetID(addr, next_idx)
                        DEBUG_PRINT( '0x%x  %d ********'%(next_ea,next_id))
                        return (next_ea, next_id)                    
        if 0 == theone[0]: 
            DEBUG_PRINT('this is veeeeeeeeeeeeery abnormal error')                    
            return (0,0)
        else:
             next_ea = theone[0]                   
             next_id = self._dbDict[next_ea]._idx_list.index(theone[1])
             return (next_ea, next_id)
        
    def Get_next_ea_id(self, ea,id,local):
        DEBUG_PRINT(('Get_next_ea'))
        theone = [0,[0xfffffffb,'']]
        next_idx = self._dbDict[ea]._idx_list[id][0]+1
        if [] != self._dbDict[ea]._xref_from:
            for canEA in self._dbDict[ea]._xref_from:
                if canEA not in self._dbDict.keys():
                    continue
                if local:
                    if canEA not in range(idaapi.get_func(ea).startEA, idaapi.get_func(ea).endEA):
                        continue            
                for nd in self._dbDict[canEA]._idx_list:
                    if local:
                        if nd[0] > self._dbDict[ea]._idx_list[id][0] and nd[0] < theone[1][0]:
                            theone = [canEA,nd]
                    else:
                        if nd[0] == next_idx:
                            theone = [canEA,nd]
                            break

        if 0 == theone[0] and 0 == local:
            for addr in self._dbDict.keys():
                for [i,j] in self._dbDict[addr]._idx_list:
                    if i == next_idx:
                        next_ea = addr
                        next_id = self.GetID(addr, next_idx)
                        DEBUG_PRINT( '0x%x  %d ********'%(next_ea,next_id))
                        return (next_ea, next_id)         

        if 0 == theone[0]: 
            DEBUG_PRINT('this is veeeeeeeeeeeeery abnormal error')                    
            return (0,0)
        else:
             next_ea = theone[0]                   
             next_id = self._dbDict[next_ea]._idx_list.index(theone[1])
             return (next_ea, next_id)
            
    def LookUP(self, startEA, ea,id,color):
        global g_ColorSnapshot
        DEBUG_PRINT('LookUP')
        next_ea = ea
        next_id = id

        if True == self._dbDict[next_ea]._shown:
            (next_ea, next_id) = self.Get_previous_ea_id(next_ea, next_id,1)
        if next_ea == 0:
#            print "ERROR in LookUP"
            return 0
        
        if 1 == color:
            COLOR_TAG = self.IDA_LF_COLOR_LOOP1    
        else:
            if 2 == color:
                COLOR_TAG = self.IDA_LF_COLOR_LOOP2
            else:
                if 3 == color:
                    COLOR_TAG = self.IDA_LF_COLOR_LOOP3      
                else:
                    COLOR_TAG = self.IDA_LF_COLOR_TAG      
                    
        DEBUG_PRINT( 'color_tag 0x%x'%COLOR_TAG)                            
        while True:
            DEBUG_PRINT(( 'LookUP While True 0x%x %d'  %(next_ea, next_id)))
            if True == self._dbDict[next_ea]._shown:
                DEBUG_PRINT( 'TruE 0x%x'%next_ea)
                DEBUG_PRINT( 'LookUp finished, tag the pre instructions blue')
                DEBUG_PRINT( 'min ea 0x%x'%(self.min_ea))
                return 1
            else:
                DEBUG_PRINT( 'paint color')
                self._ApdComm(next_ea, next_id)
                if next_ea in g_ColorSnapshot.data.keys():
                    DEBUG_PRINT( 'append color 0x%x'%next_ea)
#                     g_ColorSnapshot.data[next_ea] = idapython.GetLineColor(next_ea)
#                     g_ColorSnapshot.Save()
                    idc.SetColor(next_ea,self.CIC_ID,g_ColorSnapshot.data[next_ea])
                    self.colorsnapshot[next_ea] = g_ColorSnapshot.data[next_ea]
                else:
                    idc.SetColor(next_ea,self.CIC_ID,COLOR_TAG)
                    self.colorsnapshot[next_ea]=COLOR_TAG
            if next_ea == startEA:
                DEBUG_PRINT( 'lookup reaches startEA 0x%x'%(startEA))
                return 1
            (next_ea, next_id) = self.Get_previous_ea_id(next_ea, next_id,1)
            if next_ea == 0:
#                print "ERROR in LookUP"
                return 0
            next_idx = self._dbDict[next_ea]._idx_list[next_id][0]
            if(next_ea>self.max_ea):
                self.max_ea = next_ea
            if(next_ea<self.min_ea):
                self.min_ea = next_ea
            if next_idx > self.max_idx:
                self.max_idx = next_idx
            if next_idx < self.min_idx:
                self.min_idx = next_idx

        return 1   
        
    def LookDOWN(self, endEA, ea, id, color):
        DEBUG_PRINT( 'Lookdown')
        global g_ColorSnapshot
        next_ea = ea
        next_id = id
        if True == self._dbDict[next_ea]._shown:
            (next_ea, next_id) = self.Get_next_ea_id(next_ea, next_id,1)
      #      print 'next _ea 0x%x'%next_ea
        if next_ea == 0:
            DEBUG_PRINT( "ERROR in LookDOWN, cannot find next index")   #another possibility
            return 0
        
        if 1 == color:
            COLOR_TAG = self.IDA_LF_COLOR_LOOP1    
        else:
            if 2 == color:
                COLOR_TAG = self.IDA_LF_COLOR_LOOP2
            else:
                if 3 == color:
                    COLOR_TAG = self.IDA_LF_COLOR_LOOP3    
                else:
                    COLOR_TAG = self.IDA_LF_COLOR_TAG          
        DEBUG_PRINT( 'color_tag 0x%x'%COLOR_TAG)
        while True:            
            if True == self._dbDict[next_ea]._shown:
                DEBUG_PRINT('TruE 0x%x'%next_ea)
                DEBUG_PRINT( 'lookdown finished, tag the after instructions pink')
                DEBUG_PRINT( 'down  max ea 0x%x'%(self.max_ea))
                return 1
            else:
                self._ApdComm(next_ea, next_id)
                if next_ea in g_ColorSnapshot.data.keys():
                    DEBUG_PRINT( 'append color 0x%x'%next_ea)
#                     g_ColorSnapshot.data[next_ea] = idapython.GetLineColor(next_ea)
#                     g_ColorSnapshot.Save()
                    idc.SetColor(next_ea,self.CIC_ID,g_ColorSnapshot.data[next_ea])
                    self.colorsnapshot[next_ea] = g_ColorSnapshot.data[next_ea]
                else:
                    idc.SetColor(next_ea,self.CIC_ID,COLOR_TAG)
                    self.colorsnapshot[next_ea]=COLOR_TAG
                
            if next_ea == endEA:
                DEBUG_PRINT( 'end address ')
                return 1
#            print 'next_ea: 0x%8X next_id %d'%(next_ea, next_id)
            (next_ea, next_id) = self.Get_next_ea_id(next_ea, next_id,1)
            if next_ea == 0:
                DEBUG_PRINT( 'end of function (may be a callout)')
                DEBUG_PRINT( 'max ea 0x%x'%self.max_ea)
                return 0
            next_idx = self._dbDict[next_ea]._idx_list[next_id][0]
            if(next_ea>self.max_ea):
                self.max_ea = next_ea
            if(next_ea<self.min_ea): 
                self.min_ea = next_ea
            if next_idx > self.max_idx:
                self.max_idx = next_idx
            if next_idx < self.min_idx:
                self.min_idx = next_idx
        return 1  
    
    def Get_Down(self):
        flag = 0
        for canEA in self._dbDict[self.max_ea]._xref_from:
            if canEA > self.max_ea and canEA < self.max_ea+10:
                self.max_ea = canEA
                DEBUG_PRINT( 'Get down max ea 0x%x'%self.max_ea)
                flag = 1
        if 0 == flag:
            return(-1,-1)
        for canNODE in self._dbDict[self.max_ea]._idx_list:
            if canNODE[0] > self.max_idx:
                self.max_idx = canNODE[0]                
                break
        if [self.max_idx,canNODE[1]] not in self._dbDict[self.max_ea]._idx_list:
            return (-1,-1)
        DEBUG_PRINT( 'Get down max idx %d'%self.max_idx)
        return (self.max_ea,self.GetID(self.max_ea, self.max_idx)) 
    
    def Get_Up(self):        
        flag = 0
        for canEA in self._dbDict[self.min_ea]._xref_to:
            if canEA < self.min_ea and canEA > self.min_ea -10:
                self.min_ea = canEA                   
                DEBUG_PRINT( 'Get UP            min ea 0x%x'%self.min_ea)
                flag = 1
        if 0 == flag:
            DEBUG_PRINT( 'Get Up no min ea')
            return(-1,-1)

        if self.min_idx < self._dbDict[self.min_ea]._idx_list[0][0]:
            self.min_idx = self._dbDict[self.min_ea]._idx_list[0][0]
        else:
            pre_idx = [0,0]
            for canNODE in self._dbDict[self.min_ea]._idx_list:
                if canNODE[0] > self.min_idx:
                    break
                pre_idx = canNODE
            self.min_idx = pre_idx[0]
        DEBUG_PRINT( 'Get UP min idx %d'%self.min_idx)                
        return (self.min_ea, self.GetID(self.min_ea,self.min_idx))            
  
    def ColorCompare(self):
        DEBUG_PRINT( "in ColorCompare")
        if self.colorsnapshot=={}:
            return
        else:
            for ea in self.colorsnapshot.keys():
                ea_currentcolor = idc.GetColor(ea,idc.CIC_ITEM)
          #      print 'ea ' + hex(ea) + 'pre color'+ hex(self.colorsnapshot[ea]) + ' current color' + hex(ea_currentcolor)
                if  self.colorsnapshot[ea] != ea_currentcolor:
                    if ea == self.lastnode_ea:
                        continue
                    g_ColorSnapshot.data[ea] = ea_currentcolor
#                     print 'different happen  ' + hex (ea)
            g_ColorSnapshot.Save()
#         for ea in g_ColorSnapshot.data.keys():
#             idc.Message( hex(ea) + '   ' )
        self.colorsnapshot = {}    # may not be useful 
        return
            
    def ClearorShow(self):
        ea = idc.ScreenEA()
        (startEA,endEA) = self._GetFuncRange(ea)        
        self.ColorCompare()
        self._delComms(startEA,endEA)
        cid = [i for i,item in enumerate(self._tablelist) if item[0]==hex(startEA)]
        DEBUG_PRINT( 'clear or show')
        DEBUG_PRINT( cid)
        if cid != []:
            DEBUG_PRINT( 'in')
            cindex = cid[0]
            DEBUG_PRINT( cindex)
            DEBUG_PRINT( self._tablelist[cindex])
            if self._tablelist[cindex][2] == '0':
                self._showComms(startEA,endEA,0)
                self._tablelist[cindex][2] = '1'
            else:
                self._tablelist[cindex][2] = '0'
        return
    
    def DefaultView(self): 
        DEBUG_PRINT('IN Defaultview')
        ea = self._showFunctions()
        if 0 == ea:
            return
        idaapi.jumpto(ea, -1,1)
        (startEA,endEA) = self._GetFuncRange(ea)
        cid = [i for i,item in enumerate(self._tablelist) if item[0]==hex(startEA)]
        if cid != []:
            cindex = cid[0]
            if self._tablelist[cindex][2] == '1':
                return
            self._tablelist[cindex][2] = '1'
        else:
            print 'ea not in range' 
        self._showComms(startEA,endEA,0)
        self._choose_id = 0
        idc.Refresh()
        
                                     
    def ForwardView(self,ea,id, innermode = 0): # '>'.
        DEBUG_PRINT( 'Forward ')
        if innermode == 0:
            ea = idc.ScreenEA()
            id = self.GetID(ea, self.GetIDX(ea))
            self._choose_ea = ea
        self.max_ea = ea
        self.min_ea = ea
        self.max_idx = 0
        self.min_idx = 0
        color = 1
        (startEA,endEA) = self._GetFuncRange(ea)   
        self.ColorCompare()
        self._delComms(startEA,endEA)
#        endEA = decode_prev_insn(endEA)
        (down_ea, up_ea) = (ea,ea)
        (down_id, up_id) = (id,id)        
#        print 'max 0x%x end 0x%x'%(self.max_ea,endEA)
#        print 'min 0x%x start 0x%x'%(self.min_ea,startEA)
        while(self.max_ea <= endEA and self.min_ea >= startEA and color <4):
            DEBUG_PRINT( 'in while')
            self.LookDOWN(endEA,down_ea,down_id,color)
            self.LookUP(startEA,up_ea,up_id,color)
            if [] == self._dbDict[self.max_ea]._xref_from and [] == self._dbDict[self.min_ea]._xref_to:
                print 'max_ea and min_ea have no xref'
                break
            if [] != self._dbDict[self.max_ea]._xref_from:
                (down_ea, down_id) = self.Get_Down()
                if -1 == down_ea:
                    (down_ea, down_id) = (ea,id)
                
            if [] != self._dbDict[self.min_ea]._xref_to:  
                (up_ea, up_id) = self.Get_Up()
                if -1 == up_ea:
                    (up_ea, up_id) = (ea,id)
            DEBUG_PRINT(color)
            color = color+1 
        print 'Forward View is finished'
        idc.Refresh()
        cid = [i for i,item in enumerate(self._tablelist) if item[0]==hex(startEA)]
        if cid != []:
            cindex = cid[0]
            self._tablelist[cindex][2] = '2'
        else:
            print 'ea not in range'
        return
    
    def BackwardView(self,ea,id, innermode = 0): #'<', DEFAULT VIEW
        DEBUG_PRINT('Backward')
        if innermode == 0:
            ea = idc.ScreenEA()
            self._choose_ea = ea
            id = self.GetID(ea, self.GetIDX(ea))
        self.max_ea = ea
        self.min_ea = ea
        self.max_idx = 0
        self.min_idx = 0
        color = 1
        (startEA,endEA) = self._GetFuncRange(ea)
        self.ColorCompare()
        self._delComms(startEA,endEA)
#        endEA = decode_prev_insn(endEA)
        (down_ea, up_ea) = (ea,ea)
        (down_id, up_id) = (id,id)  
#        print 'max 0x%x end 0x%x'%(self.max_ea,endEA)
#        print 'min 0x%x start 0x%x'%(self.min_ea,startEA)

        while(self.max_ea <= endEA and self.min_ea >= startEA and color <4):
            DEBUG_PRINT( 'in while')
            DEBUG_PRINT( 'max 0x%x'%self.max_ea)
            DEBUG_PRINT( 'min 0x%x'%self.min_ea)
            self.LookUP(startEA,up_ea,up_id,color)
            self.LookDOWN(endEA,down_ea,down_id,color)
            if [] == self._dbDict[self.max_ea]._xref_from and [] == self._dbDict[self.min_ea]._xref_to:
                break
            if [] != self._dbDict[self.max_ea]._xref_from:
                (down_ea, down_id) = self.Get_Down()
                if -1 == down_ea:
                    (down_ea, down_id) = (ea,id)
                
            if [] != self._dbDict[self.min_ea]._xref_to:  
                (up_ea, up_id) = self.Get_Up()
                if -1 == up_ea:
                    (up_ea, up_id) = (ea,id)
            DEBUG_PRINT(color)
            color = color+1 
        print 'Backward View finished'
        cid = [i for i,item in enumerate(self._tablelist) if item[0]==hex(startEA)]
        if cid != []:
            cindex = cid[0]
            self._tablelist[cindex][2] = '3'
        else:
            print 'ea not in range'
        idc.Refresh()
        return
        
    def NextIdx(self): # .
        DEBUG_PRINT('in NextIdx')
        ea = idc.ScreenEA()
#        print 'Cursor is at 0x%x'%(ea)
        if ea not in self._dbDict.keys():
            print '\n0x%x has no comments'%(ea)
            return
        if ea != self._choose_ea:
            self._choose_ea = ea
            self._choose_idx = self.GetIDX(ea)
            if self._choose_idx == -1:
                print 'no comment'
                return  
            self._choose_id = self.GetID(ea,self._choose_idx)
        if self._choose_id == (self._dbDict[ea]._idx_count - 1):
            print 'Already LAST Index'
            return
        self._choose_id +=1
        id = self._choose_id
        self.ForwardView(ea, id,innermode = 1)
    
    def PreIdx(self): # ,
        DEBUG_PRINT('IN PreIdx')
        ea = idc.ScreenEA()
#        print 'Cursor is at 0x%x'%(ea)
        if ea not in self._dbDict.keys():
            print '\n0x%x has no comments'%(ea)
            return
        if ea != self._choose_ea:
            self._choose_ea = ea
            self._choose_idx = self.GetIDX(ea)
            if self._choose_idx == -1:
                print 'no comment'
                return
            self._choose_id = self.GetID(ea,self._choose_idx)

        if self._choose_id == 0:
            print 'Already FIRST Index'
            return
        self._choose_id -= 1
        id = self._choose_id;
        if id >= 0:
            self.ForwardView(ea, id,innermode = 1)
    
    def IdxChooser(self):  #'i' #THE ONLY place can change the index manually
        DEBUG_PRINT('in IdxChooser')
        ea = idc.ScreenEA()
        deflt_id = 1
        try:
            deflt_id = self.GetID(ea, self.GetIDX(ea)) + 1
        except:
            pass
        DEBUG_PRINT(ea)
        if ea not in self._dbDict.keys():
            DEBUG_PRINT( '\n0x%x has no comments'%(ea))
            return
        title = 'IndexChooser'
        cols = [['ID',4],['Index',10],['Comment',40]]
        items = []
        count = 1
        for item in self._dbDict[ea]._idx_list:
            temp = [str(count),str(item[0]),item[1]]
            items.append(temp)
            count = count + 1            
        chooser = IdxChoose2(title, cols, items,deflt = deflt_id)
        id = chooser.show()        
        if -1==id:
            idc.Message('\n Index no change\n')
        else:
            self._choose_id = id
            self._choose_ea = ea
            print '0x%x %dth index is chosen'%(ea,self._choose_id)
            self.ForwardView(ea,self._choose_id,innermode = 1)
            
    def GetIDX(self,ea):
        DEBUG_PRINT('IN GetIDX')
        idx = -1
        comm = str(idc.GetCommentEx(ea, 0))        
        if '__' not in comm:
            print 'no comment here'
            return -1
        DEBUG_PRINT(comm)
        start = comm.find(self._commMarker)+len(self._commMarker)
        if self._global == 1:
            end = comm.find('_g')
            idx = int(comm[start:end])
        else:
            end = comm.find('_L')
            idx = int(comm[start:end]) + self._dbDict[idaapi.get_func(ea).startEA]._idx_list[0][0]
        return idx
    
    def GetID(self,ea,idx):
        DEBUG_PRINT(idx)
        id = [x[0] for x in self._dbDict[ea]._idx_list].index(idx)
        DEBUG_PRINT(id)
        return id
    
    def PreNode(self):
        DEBUG_PRINT('PreNode')
        ea = idc.ScreenEA()
        local = 1
#        print 'Cursor is at 0x%x'%(ea)
        if ea not in self._dbDict.keys():
            print '\n0x%x has no comments'%(ea)
            return
        self._choose_ea = ea
        self._choose_idx = self.GetIDX(ea)   
        self._choose_id = self.GetID(ea,self._choose_idx)            

        if self._choose_idx == 0:
            print 'Already FIRST Index'
            return
        if self._choose_idx == -1:
            print 'no comment'
            return
        
        DEBUG_PRINT( 'the to show idx is %d  %x %d'%(self._choose_idx-1,self._choose_ea, self._choose_id))
        (preEA,preID) = self.Get_previous_ea_id(self._choose_ea, self._choose_id,local)
        if 0 == preEA or self._choose_idx-1 != self._dbDict[preEA]._idx_list[preID][0]:
            local = 0
            (preEA,preID) = self.Get_previous_ea_id(self._choose_ea, self._choose_id,local)
            if 0 == preEA or self._choose_idx-1 != self._dbDict[preEA]._idx_list[preID][0]:
                DEBUG_PRINT("00000000Failed to get the preNode. no xref to info" )
                return

        idaapi.jumpto(preEA, -1,1)
        self._choose_id = preID
        t_idx = self.GetIDX(preEA)
        if t_idx != -1: # no comment
#  check the show mode, if it's default need to change it into backward view, or make it simple, just repaint
            if local == 0:
                self.BackwardView(preEA, preID, innermode = 1)
            else:
                cid = [i for i,item in enumerate(self._tablelist) if item[0]==hex(idaapi.get_func(preEA).startEA)]
                if cid != []:
                    cindex = cid[0]
                    if self._tablelist[cindex][2] == '1':#if it's just default view(or backward view not added to this version), need to make it forwardview
                        self.BackwardView(preEA, preID, innermode = 1)
                t_ID = self.GetID(preEA,t_idx)
                if t_ID == preID: # do nothing, just set the color
                    if ea==self.lastnode_ea and 0!=self.lastnode_color:
                        idc.SetColor(self.lastnode_ea,self.CIC_ID,self.lastnode_color)
                    self.lastnode_ea = preEA
                    self.lastnode_color = idc.GetColor(self.lastnode_ea,self.CIC_ID)
                    idc.SetColor(preEA,self.CIC_ID,self.IDA_LF_COLOR_TAG)
                    idc.Refresh()
                    return
                else:
                   self._RmComm(preEA) 
                   self._ApdComm(preEA, preID)
        else: #no matter within the function or out, if there's no comment, need to rewrite comments
#            if local == 0:
            self.BackwardView(preEA, preID, innermode = 1)        
        if ea==self.lastnode_ea and 0!=self.lastnode_color:
            idc.SetColor(self.lastnode_ea,self.CIC_ID,self.lastnode_color)
        self.lastnode_ea = preEA
        self.lastnode_color = idc.GetColor(self.lastnode_ea,self.CIC_ID)        
        idc.SetColor(preEA,self.CIC_ID,self.IDA_LF_COLOR_TAG)       
        idc.Refresh()
        return
    
    def NextNode(self):
        DEBUG_PRINT('NextNode')
        ea = idc.ScreenEA()
        local = 1
        if 'call' == idc.GetMnem(ea) or 'ret' == idc.GetMnem(ea) or 'retn' == idc.GetMnem(ea) or 'jmp' == idc.GetMnem(ea) :
            local = 0
#        print 'Cursor is at 0x%x'%(ea)
        if ea not in self._dbDict.keys():
            print '\n0x%x has no comment'%(ea)
            return
        self._choose_ea = ea
        self._choose_idx = self.GetIDX(ea)
        self._choose_id = self.GetID(ea,self._choose_idx)   
        if self._choose_idx == -1:
            print 'no comment'
            return
        
        DEBUG_PRINT('the to show idx is %d'%(self._choose_idx+1))        
        (nextEA,nextID) = self.Get_next_ea_id(self._choose_ea, self._choose_id,local)
        DEBUG_PRINT('next node get next EA')
        if 0 == nextEA:
            print "Failed to get the NextNode"  #########
        else:
            if idaapi.get_func(nextEA).startEA == idaapi.get_func(ea).startEA:
                local = 1
            idaapi.jumpto(nextEA, -1,1)
#             if not (nextEA in g_ColorSnapshot.data):
#                 g_ColorSnapshot.data[nextEA] = idapython.GetLineColor(nextEA)
#                 g_ColorSnapshot.Save() 
            self._choose_id = nextID
            t_idx = self.GetIDX(nextEA)
            if t_idx != -1: # no comment
                if local == 0:
                    self.ForwardView(nextEA, nextID, innermode = 1)
                else:
                    cid = [i for i,item in enumerate(self._tablelist) if item[0]==hex(idaapi.get_func(nextEA).startEA)]
                    if cid != []:
                        cindex = cid[0]
                        if self._tablelist[cindex][2] == '1':#if it's just default view(or backward view not added to this version), need to make it forwardview
                            self.ForwardView(nextEA, nextID, innermode = 1)
                    else:
                        DEBUG_PRINT('NextNode??')
                    t_ID = self.GetID(nextEA,t_idx)
                    if t_ID == nextID: # do nothing, just set the color
                        if ea==self.lastnode_ea and 0!=self.lastnode_color:
                            idc.SetColor(self.lastnode_ea,self.CIC_ID,self.lastnode_color)
                        self.lastnode_ea = nextEA
                        self.lastnode_color = idc.GetColor(self.lastnode_ea,self.CIC_ID)
                        idc.SetColor(nextEA,self.CIC_ID,self.IDA_LF_COLOR_TAG)                        
                        idc.Refresh()
                        return
                    else:
                        self._RmComm(nextEA)
                        self._ApdComm(nextEA, nextID)
            else:
#                if local == 0:
                self.ForwardView(nextEA, nextID, innermode = 1)      
            if ea==self.lastnode_ea and 0!=self.lastnode_color:
                idc.SetColor(self.lastnode_ea,self.CIC_ID,self.lastnode_color)
            self.lastnode_ea = nextEA
            self.lastnode_color = idc.GetColor(self.lastnode_ea,self.CIC_ID)
            idc.SetColor(nextEA,self.CIC_ID,self.IDA_LF_COLOR_TAG)   
        idc.Refresh()
        return
    
    def printUsage(self):
        print '(IDA_RunTraceComments)'
        print ' [List all functions that have comments] Press "%s"'%_IDARUNTRACE_HOTKEY
        print '                       [Toggle comments] Press "%s"'%_IDARUNTRACE_CLEARORSHOW
        print '             [Toggle global/local index] Press "%s"'%_IDARUNTRACE_GlobalorLocal
        print '  [Select current instruction iteration] Press "%s"'%_IDARUNTRACE_CHOOSE
        print '[Previous current instruction iteration] Press "%s"' %_IDARUNTRACE_PREVIOUSINDEX
        print '    [Next current instruction iteration] Press "%s"'%_IDARUNTRACE_NEXTINDEX
        print '                        [Backwards view] Press "%s"'%_IDARUNTRACE_BACKWARD
        print '                          [Forward view] Press "%s"'%_IDARUNTRACE_FORWARD
        print '         [Previous executed instruction] Press "%s"' %_IDARUNTRACE_PRENODE
        print '             [Next executed instruction] Press "%s"'%_IDARUNTRACE_NEXTNODE
        
    @classmethod
    def registerHotKeys(cls, instanceVarName):
        #Add hotkeys
        idaapi.CompileLine('static DefaultView() { RunPythonStatement("' + instanceVarName + '.DefaultView()"); }')
        idaapi.CompileLine('static ForwardView() { RunPythonStatement("' + instanceVarName+ '.ForwardView(' + instanceVarName + '._choose_ea,' + instanceVarName + '._choose_id)"); }')
        idaapi.CompileLine('static BackwardView() { RunPythonStatement("' + instanceVarName + '.BackwardView(' + instanceVarName + '._choose_ea,' + instanceVarName + '._choose_id)"); }')
        idaapi.CompileLine('static IdxChooser() { RunPythonStatement("' + instanceVarName + '.IdxChooser()"); }')
        idaapi.CompileLine('static PreIdx() { RunPythonStatement("' + instanceVarName + '.PreIdx()"); }')
        idaapi.CompileLine('static NextIdx() { RunPythonStatement("' + instanceVarName + '.NextIdx()"); }')
        idaapi.CompileLine('static PreNode() { RunPythonStatement("' + instanceVarName + '.PreNode()"); }')
        idaapi.CompileLine('static NextNode() { RunPythonStatement("' + instanceVarName + '.NextNode()"); }')
        idaapi.CompileLine('static ClearorShow() { RunPythonStatement("' + instanceVarName + '.ClearorShow()"); }')
        idaapi.CompileLine('static GlobalorLocal() { RunPythonStatement("' + instanceVarName + '.GlobalorLocal()"); }')
        idc.AddHotkey(_IDARUNTRACE_CHOOSE, 'IdxChooser')
        idc.AddHotkey(_IDARUNTRACE_HOTKEY, 'DefaultView')
        idc.AddHotkey(_IDARUNTRACE_FORWARD, 'ForwardView')
        idc.AddHotkey(_IDARUNTRACE_BACKWARD, 'BackwardView')
        idc.AddHotkey(_IDARUNTRACE_PREVIOUSINDEX, 'PreIdx') 
        idc.AddHotkey(_IDARUNTRACE_NEXTINDEX, 'NextIdx')
        idc.AddHotkey(_IDARUNTRACE_PRENODE, 'PreNode') 
        idc.AddHotkey(_IDARUNTRACE_NEXTNODE, 'NextNode')
        idc.AddHotkey(_IDARUNTRACE_CLEARORSHOW,'ClearorShow')
        idc.AddHotkey(_IDARUNTRACE_GlobalorLocal,"GlobalorLocal")